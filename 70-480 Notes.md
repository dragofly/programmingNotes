# 70-480 Notes

### Geolocation: `navigator.geolocation`
####  .getCurrentPosition()
   
```javascript
//Get current position
.getCurrentPosition(success(position), error(e), options?)
    position = { 
        coords : {
            latitude : 1.1
            longitude : 1.1
        },
        timestamp: 0 //when the request returned
    }
    e = { code : 0-3 } 
        // 1 - PERMISSION_DENIED, 
        // 2 - POSITION_UNAVELABLE
        // 3 - TIMEOUT
    options = {
        enableHighAccuracy : true, //try to find out more precise location (may take longer)
        timeout: 10000, // how long to try to get location (default: no limit)
        maximumAge: 1000 // how old the data can be before new position is calculated
    }
```

#### .watchLocation()

```javascript
 // gets location in intervals of options.maximumAge
let g = navigator.geolocation;
let watchID = g.watchLocation(success(), error(), options?);
g.clearWatch(watchID);
```

## Web storage: `window.localStorage/sessionStorage`
* Types:
	Local - bound to website not window
	Session - removed when window is closed
* Capacity: 2 - 10MB
* Security: per session/domain

```javascript
    
	.setItem(’myKey’, ’myValue’);
            // .myKey = ’myValue’;
            // [‘myKey’] = ‘myValue’;
	.getItem(’myKey’); 
            // .myKey; 
            // [‘myKey’];
	.removeItem(‘myKey’);
	.clear() // remove all data
	.length //number of keys added
	.remainingSpace // free space in B left
	:storage(e)
            e : {
                oldValue : 1,
                newValue : 3,
                key : ‘myKey’,
                url: ‘’,
                storageArea: ‘local/session’
            }
	error: 22 (QUOTA_EXCEEDED_ERR) 
```	

## Web workers: 

* Restrictions:
    - No accas to DOM, Window, Host page and jQuery (because it is depended on the Widnow)
    - Accas to: naviagator, timers, XmlHttpRequest

* Types:
    - Dedicated: bound to one window
    - Shared: can be called from multiple widnows

### Using web worker on web page
* `onmessage(f)` // result sent from the worker
* `onerror(f)` // handle error
* `postMessage(params)` // request for processing
```javascript
let worker = new Worker('myWorker.js');
worker.onmessage = function(e) {
    let result = e.data;
    console.log(result.summery);
}; // Workers send result
worker.onerror = function(errE) { console.log(errE.message)};
let params = { param1 : 'test', param: 2 };
worker.postMessage(params); //Sends data to worker
```

### Creating a web worker
* `addEventListener`('message', f(e), true) // listener for worker
* `postMessage`(results) // calls the .onmessage() int the UI thread
```javascript
function myEventHandler(e){
    let params = e.data;
    //do calculations here
    let reulsts = myCalculator(params.param1, params.param2);
    resutls['summery'] = 'Done';
    postMessage(resutls); //calls the onmessage function;
}

addEventListener('message', myEventHandler, true)
```

### Closing worker

* `.terminate()` // Closes the worker emedietly
Is called from the UI thread
```javascript
    let worker = new Worker('myWorker.js');
    worker.terminate();
```
* `.close()` // Waits for the worker to finish processing <br/>
Must be called from the worker not from the UI thread
```javascript
addEventListener('message'), function(e) {
    if(e.data.Command === 'close'){
        this.close();
    }
}
```

## Web sockets
Full duplex communication between server and clinet: boath server and client can send and receive messages at the same time without overhead. <br />
Websockets are using the websocket protocol (`ws`)that requires much less metadata (2B) then the standard httpreques/response (100+B)

### JS implementation
* `.onopen()`
* `.onclose()`
* `.onmessage(e)` // hadle message to server
* `.onerror(e)`
* `.send(params)` // send message to server

```javascript
let webSocket = window.WebSocket || window.MozWebSocket;
let ws = new webSocket('ws://localhost:8181/');
ws.onopen = function() {};
ws.onclose = function() {};
ws.onmessage  = function(e) {
    console.log(e.data);
};
ws.onerror =  = function(e) {};
ws.send('Hi');
```

### Server implementation
Implementation is done using Flek a C# library for handling WebSockets <br />
* `.OnOpen()` // add to sockets list
* `.OnClose()` // remove form socket list
* `.OnMessage()` // handle message form the client
* `.Send()` // send message to the client
```cs
var sockets = new List<IWebSocketConnection>();
var server = new Flek.WebSocketServer("ws://localhost:8181/");
server.Start(socket = () => 
{
    socket.OnOpen = () => 
    {
        sockets.Add(socket);
    };
    socket.OnClose = () =>
    {
        sockets.Remove(socket);
    };
    socket.OnMessage = message => {
        sockets.ToList().ForEach(s => s.send(message));
    };
}
)
```

## Microdata
Standard HTML markup + vocabulary namespace used to anotate pages so that programs can interact with the page. <br />
Rich snippets testing tool can be used to test what data can a machine read from your page.

* `itemscope itemtype`="http://data-vocabulary.org/Object"
    - itemscope : define a HTML container whose child elements contain properties of the described object
    - itemtype : defins the object the child HTML elements have values for
* `itemprop`="objectProp" // from the Person vocabulary
    - added to child element that contains property of the itemtpye object
    -  it will take the `text content` of that element, for specific types it will take scr, href, dateTime.
* `itemid`="MyUniuqeID"
    - scope uniuqe item ID
* `itemref`="row0-cell1 row1-cell1"
    - element IDs that are space separated
    - defines where the child elements are if the are not strucuted as child elements of the HTML object

```html
<div id="myInfo" itemscope itemtype="http://data-vocabulary.org/Person">
<h2 itemprop="name">Juraj Murgic>
    <div id="myAdress" itemscope itemtype="http://data-vocabulary/Adress">
    <span itemprop="region">Zagreb</span>
    </div>
</div>
```