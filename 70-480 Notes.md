# 70-480 Notes

### Geolocation: `navigator.geolocation`
####  .getCurrentPosition()
   
```javascript
//Get current position
.getCurrentPosition(success(position), error(e), options?)
    position = { 
        coords : {
            latitude : 1.1
            longitude : 1.1
        },
        timestamp: 0 //when the request returned
    }
    e = { code : 0-3 } 
        // 1 - PERMISSION_DENIED, 
        // 2 - POSITION_UNAVELABLE
        // 3 - TIMEOUT
    options = {
        enableHighAccuracy : true, //try to find out more precise location (may take longer)
        timeout: 10000, // how long to try to get location (default: no limit)
        maximumAge: 1000 // how old the data can be before new position is calculated
    }
```

#### .watchLocation()

```javascript
 // gets location in intervals of options.maximumAge
let g = navigator.geolocation;
let watchID = g.watchLocation(success(), error(), options?);
g.clearWatch(watchID);
```

## Web storage: `window.localStorage/sessionStorage`
* Types:
	Local - bound to website not window
	Session - removed when window is closed
* Capacity: 2 - 10MB
* Security: per session/domain

```javascript
    
	.setItem(’myKey’, ’myValue’);
            // .myKey = ’myValue’;
            // [‘myKey’] = ‘myValue’;
	.getItem(’myKey’); 
            // .myKey; 
            // [‘myKey’];
	.removeItem(‘myKey’);
	.clear() // remove all data
	.length //number of keys added
	.remainingSpace // free space in B left
	:storage(e)
            e : {
                oldValue : 1,
                newValue : 3,
                key : ‘myKey’,
                url: ‘’,
                storageArea: ‘local/session’
            }
	error: 22 (QUOTA_EXCEEDED_ERR) 
```	

## Web workers: 

* Restrictions:
    - No accas to DOM, Window and Host page, jQuery (because it is depended on the Widnow)
    - Accas to: naviagator, timers, XmlHttpRequest

* Types:
    - Dedicated: bound to one window
    - Shared: can be called from multiple widnows

### Using web worker on web page
* `onmessage(f)` // result sent from the worker
* `onerror(f)` // handle error
* `postMessage(params)` // request for processing
```javascript
let worker = new Worker('myWorker.js');
worker.onmessage = function(e) {
    let result = e.data;
    console.log(result.summery);
}; // Workers send result
worker.onerror = function(errE) { console.log(errE.message)};
let params = { param1 : 'test', param: 2 };
worker.postMessage(params); //Sends data to worker
```

### Creating a web worker
* `addEventListener`('message', f(e), true) // listener for worker
* `postMessage`(results) // calls the .onmessage() int the UI thread
```javascript
function myEventHandler(e){
    let params = e.data;
    //do calculations here
    let reulsts = myCalculator(params.param1, params.param2);
    resutls['summery'] = 'Done';
    postMessage(resutls); //calls the onmessage function;
}

addEventListener('message', myEventHandler, true)
```

### Closing worker

* `.terminate()` // Closes the worker emedietly
Is called from the UI thread
```javascript
    let worker = new Worker('myWorker.js');
    worker.terminate();
```
* `.close()` // Waits for the worker to finish processing <br/>
Must be called from the worker not from the UI thread
```javascript
addEventListener('message'), function(e) {
    if(e.data.Command === 'close'){
        this.close();
    }
}


```